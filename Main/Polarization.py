from Modules.dependencies import *
from Modules.function_def import *
from Modules.parameters import *
from Modules.units import *

##################################### Folder manipulation #####################################

"""
Generate a dictionary with paths relative to the current file path. 
root_path and current_dir both take the directory of where this file is running from and store as string.
target_folder contains a string, which is passed down to the folder dictionary. This will allow for the creation a folder to isolate the outputs based on your criteria of preference. 
In this case, my goal is to allow for easily storing the results of different parameter values just by changing the target_folder.
Each index of the dictionary contains the path for specific outputs, e.g.:
Index 1: Output folder for text files (.cvs) for each physical function calculated
Index 2: Output folder for the plots generated by these outputs
"""

root_path = os.path.dirname(os.path.abspath(__file__))
target_folder = root_path + "/Batch_1/"
Folder_dicts = {"folders":[target_folder + "Output/Ordered/", target_folder + "Output/Perpendicular/",
						   target_folder + "Output/Parallel/", target_folder + "Output/Toroidal/"],
 				"plot_folders":[target_folder + "Output/Ordered/Plots/", target_folder + "Output/Perpendicular/Plots/",
								target_folder + "Output/Parallel/Plots/", target_folder + "Output/Toroidal/Plots/"]}



if __name__ == '__main__':

	#Find the modules being imported and its versions, passed down to a log later on
	pylist = py_session(return_list = True)


	#Make all the folders in the dictionary
	for folder in Folder_dicts["folders"]:
		os.makedirs(os.path.join(root_path,folder), exist_ok = True)
	for folder in Folder_dicts["plot_folders"]:
		os.makedirs(os.path.join(root_path,folder), exist_ok = True)



	##################################### Object Creation #####################################

	r"""
	This section defines the variables of the system. These are, trying to keep in order:
	---------------------------------- Changed to a Separate Function: run(Geom, debug), this will allow expansion of run parameters away from the front code
	Toggle_Geom: str; Simple variable to allow switching of geometric propertries via a condition. (0 = Off_Axis, 1 = Spherical)
	Geom: str; Geometry of the problem, if "Off_Axis" assigns Gamma for Off Axis, if "Spherical" else assigns Gamma for Quasi Spherical Ouflow.
	debug: bool; Boolean variable that toggles wheter or not to show the calculations for some values inside of the functions. Useful for locating problematic parts.
	-----------------------------------
	z: double; redshift.
	beta: double; velocity of the material, for spherical outflow (have to see how its calculated)
	alpha_s: double; Power law index from our model.
	alpha = double; alpha from the polarization model (have to see if same as ours)
	n: double; density of the medium.
	E: double; Fiducial Energy.
	theta_j: double;  Opening angle of the jet.
	theta: array; Observation angle.
	t: array; observed time;
	"""

	run = run(Toggle_Geom = 0, debug = True)
	z = 0.022
	beta = 1.
	alpha_s = 2.4
	alpha = 0.75
	n = 1.e-2 *numpy.power(cm,-3.)
	E = 1.e49 *erg
	theta_j = 4. *math.pi/180.
	theta = numpy.linspace(5., 20., 10) *math.pi/180.

	r"""Takes in consideration where the deceleration timescale is and force the first point of the time range to be below it"""
	if(run[0] == "Spherical"):
		t_b = timebreak_sphe(alpha_s, n, E, theta_j, theta[0])
		t  = numpy.geomspace(1e-6, 5e3, 50) *day
	elif(run[0] == "Off_Axis"):
		t_b = timebreak_off(alpha_s, n, E, theta_j, theta[0])
		t  = numpy.geomspace(1e-6, 5e3, 50) *day
	else:
		print("Please choose an appropriate geometry.")

	r"""
	This section geenerates the Lists and Dictionaries necessary for each Polarization calculation.
	For ease of undestanding, each is named in a system of $\ulcorner\text{Polarization_Type}\lrcorner$_
	$\ulcorner\text{Object_Type}\lrcorner$, with the lenght of the x-axis equivalent. For the dictionaries
	the x-axis is passed as column. 
	"""	
	t_dec_list = numpy.zeros((theta.shape[0],), dtype = object)
	t_dec_dict = {}
	t_dec_dict[r'$q$'] = theta/theta_j


	Ordered_List = numpy.zeros((t.shape[0],), dtype = object)
	Ordered_Dict = {}
	Ordered_Dict[r'$t$'] = t/day

	Perpendicular_List = numpy.zeros((t.shape[0],), dtype = object)
	Perpendicular_Dict = {}	
	Perpendicular_Dict[r'$t$'] = t/day

	Parallel_List = numpy.zeros((t.shape[0],), dtype = object)
	Parallel_Dict = {}
	Parallel_Dict[r'$t$'] = t/day

	Toroidal_List = numpy.zeros((t.shape[0],), dtype = object)
	Toroidal_Dict = {}	
	Toroidal_Dict[r'$t$'] = t/day


	r"""
	Calculation of Polarization for each mag configuration.
	Store the returned list of values in a dictionary that is converted into a Dataframe, which is then exported as a csv(table) file for future reference.
	Also calculates the time it takes for each function to execute via the time package.
	"""

	for k in range(theta.shape[0]):
		"""This is here to create a file storing the information of deceleration timescales for plotting.
		Only useful for now as I'm working with multiple values of observation angle to validate the results.
		Once it goes to the normal kind it will be only 1 value of angle and consequently 1 value of t_dec and this will no longer be needed. 
		The condition might be reusable as we might still want to plot the timescale nonetheless and it will depend on the geometry"""
		if(run[0] == "Spherical"):
			t_dec_list[k] = timebreak_sphe(alpha_s, n, E, theta_j, theta[k])
		elif(run[0] == "Off_Axis"):
			t_dec_list[k] = timebreak_off(alpha_s, n, E, theta_j, theta[k])
		name_tdec = r'$t_{{dec}}$'
		if name_tdec not in t_dec_dict:
				t_dec_dict[name_tdec] = []
		t_dec_dict[name_tdec].append(t_dec_list[k])
	t_dec_output = pandas.DataFrame(t_dec_dict)
	t_dec_output.to_csv(path_or_buf=target_folder + "t_dec_output.csv", sep = "\t")
	
	Time_Ordered = time.time()

	if(run[1]==True):
		print("\n\t\t--Ordered--\n\n")
	for k in range(theta.shape[0]):
		for l in range(t.shape[0],):
			Ordered_List[l] = Polarization_Ordered_Off_Changed(alpha_s,n, E,theta_j, theta[k], alpha,t[l], debug = run[1], Geom = run[0])
			name1 = r'$q$ = {0:.1f}'.format(theta[k]/theta_j)
			if name1 not in Ordered_Dict:
				Ordered_Dict[name1] = []
			Ordered_Dict[name1].append(Ordered_List[l])
	Ordered_Output = pandas.DataFrame(Ordered_Dict)
	Ordered_Output.to_csv(path_or_buf=Folder_dicts["folders"][0] + "Ordered_Output.csv", sep = "\t")
	Execution_Ordered = time.time() - Time_Ordered


	Time_Perpendicular = time.time()
	if(run[1]==True):
		print("\n\t\t--Perpendicular--\n\n")
	for k in range(theta.shape[0]):
		for l in range(t.shape[0],):
			Perpendicular_List[l] = Polarization_Perpendicular_Off_Changed(alpha_s,n, E,theta_j, theta[k], alpha,t[l], debug = run[1], Geom = run[0])
			name1 = r'$q$ = {0:.1f}'.format(theta[k]/theta_j)
			if name1 not in Perpendicular_Dict:
				Perpendicular_Dict[name1] = []
			Perpendicular_Dict[name1].append(Perpendicular_List[l])
	Perpendicular_Output = pandas.DataFrame(Perpendicular_Dict)
	Perpendicular_Output.to_csv(path_or_buf=Folder_dicts["folders"][1] + "Perpendicular_Output.csv", sep = "\t")
	Execution_Perpendicular = time.time() - Time_Perpendicular


	Time_Parallel = time.time()
	if(run[1]==True):
		print("\n\t\t--Parallel--\n\n")
	for k in range(theta.shape[0]):
		for l in range(t.shape[0],):
			Parallel_List[l] = Polarization_Parallel_Off_Changed(alpha_s,n, E,theta_j, theta[k], alpha,t[l], debug = run[1], Geom = run[0])
			name1 = r'$q$ = {0:.1f}'.format(theta[k]/theta_j)
			if name1 not in Parallel_Dict:
				Parallel_Dict[name1] = []
			Parallel_Dict[name1].append(Parallel_List[l])
	Parallel_Output = pandas.DataFrame(Parallel_Dict)
	Parallel_Output.to_csv(path_or_buf=Folder_dicts["folders"][2] + "Parallel_Output.csv", sep = "\t")
	Execution_Parallel = time.time() - Time_Parallel


	Time_Toroidal = time.time()
	if(run[1]==True):
		print("\n\t\t--Toroidal--\n\n")
	for k in range(theta.shape[0],):
		for l in range(t.shape[0],):
			Toroidal_List[l] = Polarization_Toroidal_Off_Changed(alpha_s,n, E,theta_j, theta[k], alpha,t[l], debug = run[1], Geom = run[0])
			name1 = r'$q$ = {0:.1f}'.format(theta[k]/theta_j)
			if name1 not in Toroidal_Dict:
				Toroidal_Dict[name1] = []
			Toroidal_Dict[name1].append(Toroidal_List[l])

	Toroidal_Output = pandas.DataFrame(Toroidal_Dict)
	Toroidal_Output.to_csv(path_or_buf=Folder_dicts["folders"][3] + "Toroidal_Output.csv", sep = "\t")
	Execution_Toiroidal = time.time() - Time_Toroidal
	


	r""" 
	Logging. Stores, in order:
	Session Date: Date and Time the code was run.
	Physical Parameters used to calculate the polarization: Geometry, alpha, Fiducial energy, density, alpha_s, redshift, time, angle, opening angle
	Computation time of each mag field: Ordered, Perpendicular, Parallel and Toroidal
	Total computation time.
	"""
	T_Log = open(target_folder + 'Info.log', 'w')
	Time_Tot = Execution_Ordered + Execution_Perpendicular + Execution_Parallel +  Execution_Toiroidal
	T_Log.write("Session date:\n{}\n".format(datetime.datetime.now()))
	T_Log.write("This session is using:\n{}\n".format(pylist))
	T_Log.write("__________________________________________________________- Physical Parameters -__________________________________________________________\n")
	T_Log.write("Geometry = {} \nalpha = {} \nE = {} \nn = {} \nalpha_s = {}\nz = {}\n".format(run[0], alpha, E/erg, n/numpy.power(cm,-3.), alpha_s, z))
	T_Log.write("t:\n{}\n".format(t/day))
	T_Log.write("theta:\n{}\n".format(theta*180./math.pi))
	T_Log.write("theta_j = {}\n".format(theta_j*180./math.pi))
	T_Log.write("Ordered Polarization calculation time is: \n --- {:0>8} --- \n".format(str(datetime.timedelta(seconds = Execution_Ordered))))
	T_Log.write("Perpendicular Polarization calculation time is: \n --- {:0>8} --- \n".format(str(datetime.timedelta(seconds = Execution_Perpendicular))))
	T_Log.write("Parallel Polarization calculation time is: \n --- {:0>8} --- \n".format(str(datetime.timedelta(seconds = Execution_Parallel))))
	T_Log.write("Toroidal Polarization calculation time is: \n --- {:0>8} --- \n".format(str(datetime.timedelta(seconds = Execution_Toiroidal))))
	T_Log.write("Total Execution time is: \n --- {:0>8} --- \n".format(str(datetime.timedelta(seconds = Time_Tot))))
	T_Log.close()
